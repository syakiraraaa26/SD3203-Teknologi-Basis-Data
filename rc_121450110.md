# -*- coding: utf-8 -*-
"""RC_121450110

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yMpHGVmc33u2bK0DZZBiLrOJVWD43zBn

# **Tugas TBD Multimedia**

**NAMA : Syakira Tsania Muthmainnah**

**NIM : 121450110**

**KELAS : RC**

# **Tiga Cara Menyimpan dan Mengakses Banyak Gambar dengan Python**

artikel : https://realpython.com/storing-images-in-python/#storing-many-images

Pada artikel, berisi tutorial yang membahas berbagai cara menyimpan dan mengakses gambar dengan Python buat  nangani kumpulan data besar, seperti dalam jaringan saraf konvolusional (CNN). Selain menyimpan gambar sebagai file .png atau .jpg, opsi lain termasuk memakai database seperti LMDB atau format data hierarki seperti HDF5. kalau diperhatikan dengan baik, penggunaan yang intensif pada tugas seperti pelatihan CNN dengan dataset besar seperti ImageNet, tutorial ini menyoroti pentingnya efisiensi penyimpanan dan akses gambar buat menghindari kelebihan beban memori dan waktu. Metode pada tutorial ini berisi perbedaan kinerja antara membaca dan menulis gambar tunggal dan banyak, serta perbandingan penggunaan disk antara tiga pendekatan tersebut. Tutorial ini ditujukan buat   mereka yang memiliki pemahaman dasar tentang Python dan gambar sebagai array angka multi-dimensi.

##pengumpulan data

Dalam mengimplementasi tutorial, hal pertama yang dilakukan adalah
mengumpulkan data, dengan memakai kumpulan data CIFAR-10, yang terdiri dari 60 ribu gambar berukuran 32x32 piksel berwarna, dengan berbagai kelas objek seperti anjing, kucing, dan pesawat terbang. Meskipun tidak terlalu besar, kalau memakai kumpulan data TinyImages lengkap, diperlukan mungkin 400 GB ruang disk. Tutorial meminta buat mengunduh CIFAR-10 buat mengikuti contoh kode di artikel ini. Setelah diunduh dan diekstraksi, file gambar tersebut tersimpan dalam batch memakai cPickle.

Kode berikut menghapus masing-masing dari lima file batch dan memuat semua gambar ke dalam array NumPy:
"""

import numpy as np
import pickle
from pathlib import Path

# Path to the unzipped CIFAR data
data_dir = Path("data/cifar-10-batches-py/")

# Unpickle function provided by the CIFAR hosts
def unpickle(file):
    with open(file, "rb") as fo:
        dict = pickle.load(fo, encoding="bytes")
    return dict

images, labels = [], []
for batch in data_dir.glob("data_batch_*"):
    batch_data = unpickle(batch)
    for i, flat_im in enumerate(batch_data[b"data"]):
        im_channels = []
        # Each image is flattened, with channels in order of R, G, B
        for j in range(3):
            im_channels.append(
                flat_im[j * 1024 : (j + 1) * 1024].reshape((32, 32))
            )
        # Reconstruct the original image
        images.append(np.dstack((im_channels)))
        # Save the label
        labels.append(batch_data[b"labels"][i])

print("Loaded CIFAR-10 training set:")
print(f" - np.shape(images)     {np.shape(images)}")
print(f" - np.shape(labels)     {np.shape(labels)}")

"""Kode di atas dipake buat ngambil dan muat data CIFAR-10 yang udah diunduh dan diekstraksi. Fungsi unpickle dipake buat  buka dan baca file batch CIFAR-10 yang disimpen pake format pickle. Lewat pengulangan (loop), tiap gambar dalam setiap batch di-unflatten dari bentuk yang udah diproses (flattened) jadi bentuk aslinya, dengan tiga saluran warna (R, G, B) di-stack balik buat  jadi gambar lengkap berukuran 32x32 piksel. Hasil gambar dan label dari tiap batch dimasukin ke dalam daftar (list) images dan labels secara berturut-turut. Setelah semua batch diproses, ukuran dari images dan labels dicetak buat  cek dimensinya. Kode ini bertujuan buat  siapin data latih CIFAR-10 dalam format yang sesuai buat  dipake dalam pelatihan model machine learning. Jadi, semua gambar sekarang ada di RAM dalam variabel images, dengan metadata terkait di labels, dan siap buat  dimanipulasi. Selanjutnya, tutorial minta buat  install paket Python yang bakal dipake buat  ketiga metode tersebut.

##Pengaturan buat Menyimpan Gambar di Disk

Dalam mengikuti tutorial ini, pen-tutor meminta buat menginstal Python 3.x di sistem. Instal library Pillow buat manipulasi gambar dengan menjalankan perintah:

```
$ pip install Pillow
```
dapat juga memakai Anaconda buat instalasi:


```
$ conda install -c conda-forge pillow
```

Diharapkan buat memastikan tidak memiliki instalasi lama dari Python Imaging Library (PIL), karena PIL tidak lagi kompatibel dengan Python 3.x. Setelah instalasi selesai, terus selanjutnya siap buat menyimpan dan membaca gambar dari disk memakai Python.

##memulai dengan lmdb

LMDB (Lightning Memory-Mapped Database) adalah sistem penyimpanan data yang cepat dan efisien, dengan memakai struktur pohon B+ buat mengatur data. Dibandingkan dengan database relasional, LMDB diminati
orang orang karena memakai file yang dilokasikan ke memori buat mengakses nilai kunci secara langsung, jadi ga perlu salin data ke memori. Sehingga bisa meningkatkan efisiensi akses data, khsusunya karena struktur pohon B+ disesuaikan dengan ukuran halaman sistem operasi yang dipake. buat  gunain LMDB dengan Python, bisa instal memakai pip atau Anaconda dengan perintah:
```
$ pip install lmdb

```

Kalau instalasi udah selesai, langkah sealanjutnya bisa mengimpor modul lmdb dari shell Python buat memulai penggunaan LMDB.

## memulai dengan HDF5

HDF5 (Hierarchical Data Format) adalah suatu format file yang dipakai buat  simpan data ilmiah yang portable dan juga kompak, HDF5 juga di bangun oleh National Center for Supercomputing Applications. Kalau di format HDF5, juga juga dua jenis objek: kumpulan data (dataset) yang berupa array multidimensi, dan grup yang dapat berisi kumpulan data atau grup lainnya. Kumpulan data dapat simpan array dengan ukuran dan tipe data apa pun, tetapi harus sama dalam dimensi dan tipe data. Instal modul h5py buat Python memakai pip atau Anaconda


```
$ pip install h5py
```

Kalau instalasi udah selesai, Dipastiin bisa impor h5py dari shell Python buat mulai memakai fitur-fitur HDF5.

##menyimpan 1 gambar

Terus, bandingkan kuantitatif antara beberapa metode buat membaca dan menulis file, serta penggunaan memori disk yang terlibat. Pertama tama bakal membandingkan kinerja dengan memakai jumlah file yang berbeda, mulai dari satu gambar hingga 100.000 gambar, dengan memakai lima kumpulan CIFAR-10 yang memiliki total 50.000 gambar.

Pertama, siapin struktur folder buat setiap metode, yang bakal berisi file atau gambar dari database. Path dari modul pathlib buat menentukan jalur direktori:

```
from pathlib import Path

disk_dir = Path("data/disk/")
lmdb_dir = Path("data/lmdb/")
hdf5_dir = Path("data/hdf5/")

disk_dir.mkdir(parents=True, exist_ok=True)
lmdb_dir.mkdir(parents=True, exist_ok=True)
hdf5_dir.mkdir(parents=True, exist_ok=True)

```

Dengan struktur folder yang sudah disiapkan, lalu dapat melanjutkan dengan menjalankan eksperimen memakai contoh kode buat melakukan tugas dasar dengan tiga metode berbeda: penyimpanan ke disk, memakai LMDB, dan memakai HDF5.  bakal memakai modul timeit dari pustaka standar Python buat mengukur waktu eksekusi eksperimen.

Meskipun tujuan utama artikel ini bukan buat mempelajari detail API dari berbagai paket Python, pemahaman prinsip dasar implementasi bakal sangat membantu.  bakal membahas prinsip umum dan memberikan contoh kode buat melakukan eksperimen penyimpanan memakai metode yang berbeda.

## menyimpan ke disk

Selanjutnya bakal melakukan tugas yang sama dengan menyimpan gambar memakai metode LMDB.



```
import lmdb

def store_single_lmdb(image, image_id, label):
    ''' Stores a single image in LMDB database.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    '''
    # Open LMDB environment
    env = lmdb.open(str(lmdb_dir), map_size=int(1e9))  # Open LMDB environment with a large map size

    # Begin write transaction
    with env.begin(write=True) as txn:
        # Convert image to byte array
        img_byte = image.tobytes()

        # Store image and label in LMDB
        txn.put(f"{image_id}".encode("ascii"), img_byte)
        txn.put(f"{image_id}_label".encode("ascii"), str(label).encode("ascii"))

    # Close LMDB environment
    env.close()

```


Dalam fungsi store_single_lmdb, dipake modul lmdb buat menyimpan gambar dan label ke dalam LMDB database. Pertama, buka lingkungan LMDB dengan ukuran peta yang besar. terus selanjutnya, mulai transaksi tulis (write=True) dan menyimpan gambar sebagai byte array memakai txn.put. Label juga disimpan sebagai string terenkripsi dengan memakai txn.put.

Dipastiin buat menutup lingkungan LMDB setelah selesai dengan env.close().

Sehingga, dapat menyimpan gambar ke dalam LMDB database dengan memanggil fungsi store_single_lmdb dengan array gambar, ID unik gambar, dan label sebagai parameter.

#menyimpan ke lmdb

LMDB (Lightning Memory-Mapped Database) adalah sistem penyimpanan nilai kunci di mana setiap entri disimpan sebagai array byte. Dalam konteks kami, kunci bakal menjadi pengidentifikasi unik buat setiap gambar, sementara nilai bakal menjadi representasi gambar itu sendiri dalam bentuk byte array. buat menyimpan data meta gambar bersama dengan gambar, dapat memakai serialisasi seperti pickle. Ini memungkinkan penyimpanan data gambar dan meta data bersama-sama, yang memudahkan pengambilan informasi saat memuat kembali data dari disk.

buat  kelas CIFAR_Image buat merepresentasikan gambar dan meta datanya:



```
class CIFAR_Image:
    def __init__(self, image, label):
        self.channels = image.shape[2]
        self.size = image.shape[:2]
        self.image = image.tobytes()
        self.label = label

    def get_image(self):
        image = np.frombuffer(self.image, dtype=np.uint8)
        return image.reshape(*self.size, self.channels)

```

terus selanjutnya, saat menyimpan gambar ke LMDB, perlu menghitung map_size yang bakal dipake oleh database. map_size adalah perkiraan jumlah memori yang bakal dipake oleh LMDB. Ini dapat dihitung sebagai jumlah byte yang dipake oleh gambar dikalikan dengan faktor tertentu (misalnya, 10).



```
def store_single_lmdb(image, image_id, label):
    map_size = image.nbytes * 10  # Estimating map size based on image size

    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), map_size=map_size)

    with env.begin(write=True) as txn:
        value = CIFAR_Image(image, label)
        key = f"{image_id:08}"
        txn.put(key.encode("ascii"), pickle.dumps(value))

    env.close()

```

Dalam fungsi store_single_lmdb, buka lingkungan LMDB dengan ukuran peta yang diestimasi. terus selanjutnya, simpan objek CIFAR_Image yang telah diserialisasi dengan pickle ke dalam LMDB database dengan memakai kunci yang unik sebagai identifikasi.

Jadi, siap buat menyimpan gambar ke dalam LMDB database. Selanjutnya, mari  lihat cara memakai metode terakhir, HDF5.

##menyimpan dengan HDF5

Selanjutnya, lihat cara menyimpan satu gambar ke dalam file HDF5 dengan mempertimbangkan penanganan data gambar dan metadata secara terpisah.



```
import h5py

def store_single_hdf5(image, image_id, label):
    ''' Stores a single image to an HDF5 file.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    '''
    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "w")

    # Create a dataset for the image in the file
    dataset = file.create_dataset(
        "image", np.shape(image), h5py.h5t.STD_U8BE, data=image
    )

    # Create a dataset for the metadata in the file
    meta_set = file.create_dataset(
        "meta", np.shape(label), h5py.h5t.STD_U8BE, data=label
    )

    # Close the HDF5 file
    file.close()

```

Dalam fungsi store_single_hdf5, buat  file HDF5 baru dengan memakai h5py.File. terus selanjutnya, buat  dua dataset di dalam file tersebut: satu buat menyimpan gambar (image) dan satu lagi buat menyimpan metadata (meta). Dataset tersebut memakai tipe data h5py.h5t.STD_U8BE buat menyimpan data bilangan bulat 8-bit yang tidak ditandatangani.

Pilihan tipe data yang tepat sangat penting karena bakal mempengaruhi waktu proses dan persyaratan penyimpanan HDF5. Dipastiin buat memilih tipe data yang sesuai dengan kebutuhan aplikasi.

Dengan fungsi store_single_hdf5, dapat dengan mudah menyimpan satu gambar bersama dengan metadata-nya ke dalam file HDF5. Ini dapat pendekatan yang fleksibel dan efisien buat menyimpan dan mengakses data gambar dengan Python memakai HDF5.

##Eksperimen buat Menyimpan Satu Gambar



```
from timeit import timeit

# Dictionary to store timings for each method
store_single_timings = dict()

for method in ("disk", "lmdb", "hdf5"):
    # Measure time for storing single image using the specified method
    t = timeit(
        "_store_single_funcs[method](image, 0, label)",
        setup="image=images[0]; label=labels[0]",
        number=1,
        globals=globals(),
    )
    # Store the timing in the dictionary
    store_single_timings[method] = t
    # Print the method and time usage
    print(f"Method: {method}, Time usage: {t}")

```

Siapkan tiga fungsi buat menyimpan satu gambar ke dalam metode yang berbeda: store_single_disk buat penyimpanan langsung ke disk sebagai file .png, store_single_lmdb buat menyimpan ke LMDB, dan store_single_hdf5 buat menyimpan ke HDF5. Fungsi-fungsi ini dimasukkan ke dalam sebuah kamus _store_single_funcs.

Selanjutnya, lakukan percobaan buat menyimpan gambar pertama dari dataset CIFAR memakai ketiga metode tersebut, dan mengukur waktu yang dibutuhkan buat masing-masing metode memakai fungsi timeit. Hasil percobaan tersebut menunjukkan waktu eksekusi buat menyimpan gambar tunggal beserta metadata-nya dengan setiap metode:

store_single_disk: 1,915 mdtk (milidetik)

store_single_lmdb: 1,203 ms (milidetik)

store_single_hdf5: 8,243 ms (milidetik)

Dari hasil percobaan ini, dapat disimpulkan bahwa semua metode penyimpanan tersebut relatif cepat. Namun, penggunaan memori berbeda-beda antara metode, dengan LMDB memakai lebih banyak memori dibandingkan dengan penyimpanan langsung ke disk dan HDF5.

Meskipun LMDB memiliki sedikit keunggulan dalam kinerja waktu, penggunaan langsung ke disk (store_single_disk) masih dapat pilihan yang baik karena format yang mudah dibaca manusia dan kemudahan akses dari browser sistem file apa pun.

Jadi, ini memberikan gambaran tentang performa dan karakteristik relatif dari masing-masing metode penyimpanan yang dipake dalam eksperimen ini. Pilihan terbaik antara metode tergantung pada kebutuhan proyek dan pertimbangan spesifik terkait kinerja dan efisiensi penggunaan memori.

##menyimpan banyak Gambar

Kode\ pada artikel, telah menjelaskan cara menyesuaikan kode buat menyimpan banyak gambar memakai berbagai metode penyimpanan seperti disk, LMDB, dan HDF5. Berikut adalah ringkasan singkat dari langkah-langkah yang dilakukan:

- Fungsi store_many_disk(images, labels):

Fungsi ini dipake buat menyimpan sejumlah besar gambar ke dalam file disk. Setiap gambar disimpan sebagai file .png dengan nama yang unik berdasarkan indeksnya. Label-label dari gambar juga disimpan ke dalam file .csv.

- Fungsi store_many_lmdb(images, labels):
Fungsi ini dipake buat menyimpan sejumlah besar gambar ke dalam database LMDB.
Seluruh gambar dan labelnya disimpan dalam satu transaksi LMDB, dengan setiap gambar dienkapsulasi dalam objek CIFAR_Image dan disimpan dengan memakai indeks sebagai kuncinya.

- Fungsi store_many_hdf5(images, labels):
Fungsi ini dipake buat menyimpan sejumlah besar gambar ke dalam file HDF5.
Seluruh array gambar (images) dan label (labels) disimpan dalam satu file HDF5, di mana keduanya dianggap sebagai dataset.

- Persiapan Kumpulan Data:
Sebelum menjalankan eksperimen, kumpulan data gambar (images) dan label (labels) diperbesar menjadi 100.000 gambar dengan memakai fungsi np.concatenate.

Hal ini dilakukan buat mempersiapkan data agar dapat diuji hingga 100.000 gambar.
Dengan melakukan penyesuaian seperti di atas, dapat dengan efisien menyimpan dan mengelola sejumlah besar gambar dengan berbagai metode penyimpanan yang telah diimplementasikan. Langkah-langkah ini memungkinkan buat memanfaatkan kelebihan dan fungsionalitas masing-masing metode penyimpanan sesuai dengan kebutuhan aplikasi atau proyek.

##eksperimen buat menyimpan gambar banyak

buat menjalankan eksperimen tersebut, dipake dictionary _store_many_funcs yang berisi fungsi-fungsi buat menyimpan banyak gambar ke dalam disk, LMDB, dan HDF5.



```
_store_many_funcs = dict(
    disk=store_many_disk, lmdb=store_many_lmdb, hdf5=store_many_hdf5
)

```

terus selanjutnya, dilakukan iterasi melalui jumlah batas (cutoffs) yang telah didefinisikan sebelumnya dan metode penyimpanan (disk, lmdb, hdf5). buat setiap kombinasi, waktu yang diperlukan buat menyimpan gambar-gambar dengan jumlah tertentu diukur memakai timeit.



```
from timeit import timeit

store_many_timings = {"disk": [], "lmdb": [], "hdf5": []}

for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_store_many_funcs[method](images_, labels_)",
            setup="images_=images[:cutoff]; labels_=labels[:cutoff]",
            number=1,
            globals=globals(),
        )
        store_many_timings[method].append(t)
        print(f"Method: {method}, Time usage: {t}")

```
Hasil dari eksperimen ini adalah store_many_timings, yang berisi waktu yang diperlukan buat menyimpan gambar dalam format yang berbeda dengan jumlah yang bervariasi.

##output hasil eksperimen

Selanjutnya, hasil dari eksperimen tersebut divisualisasikan memakai matplotlib. Fungsi plot_with_legend dipake buat membuat  dua jenis plot: plot linier dan plot logaritmik.



```
import matplotlib.pyplot as plt

# Function to plot data with legends
def plot_with_legend(
    x_range, y_data, legend_labels, x_label, y_label, title, log=False
):
    plt.style.use("seaborn-whitegrid")
    plt.figure(figsize=(10, 7))

    if len(y_data) != len(legend_labels):
        raise TypeError(
            "Error: number of data sets does not match number of labels."
        )

    all_plots = []
    for data, label in zip(y_data, legend_labels):
        if log:
            temp, = plt.loglog(x_range, data, label=label)
        else:
            temp, = plt.plot(x_range, data, label=label)
        all_plots.append(temp)

    plt.title(title)
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.legend(handles=all_plots)
    plt.show()

# Getting the store timings data to display
disk_x = store_many_timings["disk"]
lmdb_x = store_many_timings["lmdb"]
hdf5_x = store_many_timings["hdf5"]

# Plotting the storage time data
plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Storage time",
    log=False,
)

# Plotting the log storage time data
plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Log storage time",
    log=True,
)

```

outputnya :

Analisis dalam tulisan tersebut membahas perbandingan waktu penyimpanan gambar memakai format .png (disk), LMDB, dan HDF5. Grafik pertama menunjukkan perbedaan waktu penyimpanan yang signifikan antara metode .png (disk) dan LMDB/HDF5. Proses penyimpanan .png cenderung lebih cepat dan konsisten terhadap jumlah gambar.

Di sisi lain, grafik kedua memakai skala log buat menyoroti perbedaan waktu secara lebih rinci. Meskipun HDF5 memulai dengan kecepatan yang lebih lambat daripada LMDB, grafik log menunjukkan bahwa HDF5 menjadi lebih efisien seiring peningkatan jumlah gambar. LMDB menunjukkan kinerja yang lebih konsisten tetapi dengan waktu yang relatif lebih lama, khsusunya dengan skala data yang lebih besar.

Kesimpulannya, meskipun hasilnya bisa berbeda tergantung pada faktor mesin dan parameter, metode LMDB dan HDF5 layak dipertimbangkan karena kinerja yang baik dalam skenario penyimpanan gambar dalam jumlah besar. LMDB lebih cocok buat keamanan dan konsistensi data, sedangkan HDF5 lebih cocok buat skalabilitas dan kinerja dalam skala data yang besar.

##baca satu gambar

- dari disk

Fungsi read_single_disk dipake buat membaca satu gambar dan metadata terkait dari file .png dan .csv di sistem file disk. Berikut adalah penjelasan singkat dan analisis kode tersebut:


```
def read_single_disk(image_id):
    ''' Stores a single image to disk.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    '''
    # Read the image from .png file
    image = np.array(Image.open(disk_dir / f"{image_id}.png"))

    # Read the label from .csv file
    with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        label = int(next(reader)[0])  # Read the first value from the CSV file as label

    return image, label

```


Fungsi read_single_disk dipake buat membaca satu gambar beserta metadata terkait dari file .png dan .csv yang disimpan di sistem file disk. Proses membaca gambar melibatkan penggunaan modul Pillow buat membuka dan mengonversi gambar menjadi array NumPy, sehingga memungkinkan representasi gambar yang dapat dipake dalam pemrosesan data lebih lanjut. Selain itu, fungsi ini juga membaca metadata (label) dari file .csv terkait gambar tersebut memakai modul csv Python.

Keuntungan dari memakai metode penyimpanan seperti .png dan .csv adalah kejelasan dan kemudahan dalam membaca dan menulis data secara terpisah. Namun, pendekatan ini mungkin kurang efisien dalam hal kinerja dibandingkan dengan metode penyimpanan yang lebih canggih seperti LMDB atau HDF5, khsusunya saat menangani banyak data gambar secara bersamaan. Penggunaan file .csv juga memberikan fleksibilitas dalam menyimpan metadata terkait gambar dalam format yang mudah dibaca dan dimodifikasi.

Dalam konteks perbandingan dengan metode penyimpanan yang lebih canggih seperti LMDB atau HDF5, fungsi ini menunjukkan pendekatan yang lebih sederhana dan mudah dipahami dalam membaca data gambar dan metadata dari penyimpanan disk tradisional. Namun, buat aplikasi yang membutuhkan kinerja tinggi atau penanganan besar data gambar, metode penyimpanan yang lebih canggih seperti LMDB atau HDF5 mungkin lebih sesuai buat dipake.

- dari lmdb


```
def read_single_lmdb(image_id):
    ''' Stores a single image to LMDB.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    '''
    # Open the LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Encode the key the same way as we stored it
        data = txn.get(f"{image_id:08}".encode("ascii"))
        # Remember it's a CIFAR_Image object that is loaded
        cifar_image = pickle.loads(data)
        # Retrieve the relevant bits
        image = cifar_image.get_image()
        label = cifar_image.label
    env.close()

    return image, label
```

Fungsi read_single_lmdb dipake buat membaca satu gambar beserta metadata terkait dari basis data LMDB dalam mode baca saja. Langkah-langkahnya termasuk membuka lingkungan LMDB dengan mode baca saja (readonly=True), memulai transaksi baca, dan terus selanjutnya mengambil gambar dan label terkait dari lingkungan LMDB memakai kunci yang sesuai.

Penggunaan readonly=True saat membuka lingkungan LMDB menunjukkan bahwa transaksi ini hanya buat membaca data tanpa melakukan penulisan. Dengan memakai modul pickle,  dapat mengembalikan objek CIFAR_Image dari data yang disimpan di LMDB, memungkinkan akses ke gambar dan metadata yang tersimpan.

Metode penyimpanan seperti LMDB atau HDF5 sering dipilih buat aplikasi dengan kebutuhan kinerja tinggi dan skala besar, karena mereka dapat mengelola data secara efisien dalam skenario yang membutuhkan pemrosesan gambar besar.

- dari HDF5


```
def read_single_hdf5(image_id):
    ''' Stores a single image to HDF5.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    '''
    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")

    image = np.array(file["/image"]).astype("uint8")
    label = int(np.array(file["/meta"]).astype("uint8"))

    return image, label
```


Fungsi read_single_hdf5 dipake buat membaca satu gambar beserta metadata terkait dari file HDF5. Prosesnya mirip dengan proses menulis, di mana  membuka file HDF5 dan terus selanjutnya mengakses dataset yang mengandung gambar dan metadata dengan memakai nama dataset yang sesuai.

Dalam kode ini, dipake modul h5py buat membuka file HDF5 dan terus selanjutnya mengambil array gambar dan metadata dari dataset yang telah ditentukan sebelumnya (/image buat gambar dan /meta buat metadata). Array gambar dan metadata dikonversi ke tipe data uint8 sebelum dikembalikan.

Pendekatan ini memungkinkan akses yang efisien ke data gambar yang disimpan dalam format HDF5. Fungsi ini juga dimasukkan ke dalam kamus _read_single_funcs bersama dengan fungsi baca dari format lainnya seperti disk dan LMDB buat eksperimen selanjutnya. Dengan memakai format HDF5, didapatkan manfaat kinerja yang baik buat operasi baca dan tulis pada data gambar yang besar.

##membaca banyak gambar

caranya dengan :
- Menyesuaikan Kode buat Banyak Gambar



```
def read_many_disk(num_images):
    ''' Reads image from disk.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    '''
    images, labels = [], []

    # Loop over all IDs and read each image in one by one
    for image_id in range(num_images):
        images.append(np.array(Image.open(disk_dir / f"{image_id}.png")))

    with open(disk_dir / f"{num_images}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for row in reader:
            labels.append(int(row[0]))
    return images, labels

def read_many_lmdb(num_images):
    ''' Reads image from LMDB.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    '''
    images, labels = [], []
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Read all images in one single transaction, with one lock
        # We could split this up into multiple transactions if needed
        for image_id in range(num_images):
            data = txn.get(f"{image_id:08}".encode("ascii"))
            # Remember that it's a CIFAR_Image object
            # that is stored as the value
            cifar_image = pickle.loads(data)
            # Retrieve the relevant bits
            images.append(cifar_image.get_image())
            labels.append(cifar_image.label)
    env.close()
    return images, labels

def read_many_hdf5(num_images):
    ''' Reads image from HDF5.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    '''
    images, labels = [], []

    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "r+")

    images = np.array(file["/images"]).astype("uint8")
    labels = np.array(file["/meta"]).astype("uint8")

    return images, labels

_read_many_funcs = dict(
    disk=read_many_disk, lmdb=read_many_lmdb, hdf5=read_many_hdf5
)
```

Fungsi read_many_disk, read_many_lmdb, dan read_many_hdf5 buat membaca banyak gambar dari tiga format penyimpanan yang berbeda: disk, LMDB, dan HDF5.

Fungsi read_many_disk(num_images) membaca gambar dari disk satu per satu dengan membuka setiap file .png dan mengambil label metadata dari file .csv. Proses ini bisa lambat buat jumlah gambar besar karena membaca secara terpisah.

Fungsi read_many_lmdb(num_images) membaca gambar dari LMDB dalam satu transaksi baca memakai lingkungan LMDB yang telah dibuka sebelumnya. Setiap gambar dan labelnya diambil dari objek CIFAR_Image yang disimpan dalam LMDB.

Fungsi read_many_hdf5(num_images) membaca gambar dari file HDF5 dengan membuka file tersebut dan mengambil array gambar (images) dan metadata (labels) dari dataset yang sesuai.

Kinerja membaca dari tiga format penyimpanan dapat bervariasi tergantung pada jumlah gambar yang dibaca. LMDB biasanya memberikan kinerja yang baik karena dapat membaca sejumlah besar gambar dalam satu transaksi. Namun, proses membaca dari disk satu per satu dapat menjadi lebih lambat khsusunya buat jumlah gambar yang besar.

Dengan fungsi ini, eksperimen dapat dilakukan buat membandingkan kinerja membaca dari tiga format penyimpanan berbeda tergantung pada jumlah gambar yang dibaca. Semua fungsi membaca ini dimasukkan ke dalam kamus _read_many_funcs buat kemudahan penggunaan dan pengujian selanjutnya.


- eksperimennya :

```
from timeit import timeit

read_many_timings = {"disk": [], "lmdb": [], "hdf5": []}

for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_read_many_funcs[method](num_images)",
            setup="num_images=cutoff",
            number=1,
            globals=globals(),
        )
        read_many_timings[method].append(t)

        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, No. images: {cutoff}, Time usage: {t}")
```
output :

Grafik menggambarkan perbedaan waktu yang diperlukan buat membaca gambar dari tiga format penyimpanan yang berbeda: file .png (disk), LMDB, dan HDF5.

Grafik pertama menunjukkan waktu baca dalam satuan normal (detik), menyoroti perbedaan besar antara membaca dari file .png dan LMDB atau HDF5. Waktu baca dari file .png cenderung lebih lambat karena harus membuka dan membaca setiap gambar dan metadata secara terpisah.

Grafik kedua menunjukkan variasi waktu dalam skala logaritmik, yang membantu  melihat perbedaan relatif dengan jumlah gambar yang berbeda. Pada grafik ini,  bisa melihat bahwa HDF5 awalnya lebih lambat dibandingkan LMDB ketika jumlah gambar masih sedikit, tetapi perbedaannya berkurang ketika jumlah gambar bertambah. Akhirnya, dengan jumlah gambar yang besar, HDF5 menjadi sedikit lebih cepat daripada LMDB.

Dalam konteks praktis, waktu membaca data (seperti gambar) seringkali lebih penting daripada waktu menulis, khsusunya saat melatih model seperti jaringan neural dengan kumpulan data besar. Misalnya, kalau waktu baca berbeda antara 40 detik dan 4 detik buat seluruh kumpulan data, perbedaan ini bakal memengaruhi durasi pelatihan model secara signifikan. Perbedaan tersebut bisa berarti menunggu enam jam versus empat puluh menit buat melatih model.

Dengan demikian, memilih format penyimpanan yang optimal (seperti LMDB atau HDF5) buat membaca data dengan cepat dapat sangat berpengaruh pada efisiensi dan waktu pelatihan model yang akhirnya memengaruhi pengembangan dan eksperimen di bidang pembelajaran mesin dan kecerdasan buat an.

##mempertimbangkan penggunaan disk

Pada konteks menyimpan kumpulan data gambar sangat besar seperti 3TB, kecepatan dan penggunaan ruang disk menjadi penting. Metode penyimpanan seperti .png biasa, HDF5, dan LMDB memiliki dampak langsung pada penggunaan ruang disk.

HDF5 dan LMDB memakai lebih banyak ruang disk dibandingkan .png karena struktur data yang lebih efisien, tetapi memberikan kinerja baca/tulis yang baik buat data besar. LMDB bergantung pada caching dan struktur halaman OS, sementara HDF5 cocok buat gambar berukuran besar.

Pemilihan metode penyimpanan bergantung pada keseimbangan kinerja, efisiensi ruang disk, dan kebutuhan aplikasi. Pemahaman karakteristik metode ini membantu dalam memilih metode penyimpanan yang optimal buat kumpulan data gambar besar.

# KESIMPULAN

Dalam artikel ini, di pelajari tiga cara buat menyimpan dan mengakses banyak gambar memakai Python. Metode pertama adalah menyimpan gambar sebagai file .png, yang dapat cara yang paling umum dan intuitif. Namun, dipelajari dua metode lain yang mungkin lebih efisien buat penanganan data yang besar. Metode kedua adalah memakai format HDF5, yang memungkinkan buat menyimpan gambar bersama dengan data tambahan dalam struktur yang terorganisir. Ini bermanfaat buat kinerja dan manajemen data yang lebih baik. Metode ketiga adalah memakai LMDB (Lightning Memory-Mapped Database), yang menyimpan gambar sebagai nilai kunci dalam bentuk byte array. Ini sangat efisien buat akses data yang cepat karena dilokasikan langsung ke memori. Ketiga metode ini memiliki kelebihan dan kelemahan masing-masing tergantung pada kasus penggunaan dan ukuran data. Tidak ada metode penyimpanan yang sempurna, dan pilihan terbaik tergantung pada kebutuhan spesifik. Selain metode yang telah dibahas, masih banyak lagi metode penyimpanan data yang mungkin berguna, seperti LevelDB, Feather, TileDB, Badger, BoltDB, dan lainnya. Pilihan terbaik tergantung pada tipe data dan skenario penggunaan yang dihadapi. Semoga penjelasan ini memberikan gambaran yang jelas tentang cara menyimpan dan mengakses gambar dalam pengembangan perangkat lunak dengan Python.
"""